1. React is a Component-Driven User Interfaces
    JSX -> javascript syntax eXtension
2. React is a JS library for building user Interfaces
3. What is exactly a component -> all user Interfaces are made of components
    -> Reusesable building blocks in your user interface -> components are in the end, combinations of HTML, CSS, JS
4. React split big chunks of code into smaller readable functions
5. React uses declarative approach
    -> You will always define the desired target state
    -> React's job to figure out the actual JS DOM instructions
    -> Makes Developer's job easier

React
-> Index.js is the first file that gets loaded

-> Good and best practice to put new component on a different file
-> A component in react is just a javascript function


Naming convention:
-> Capitalize
-> Lowercased elements are built-in components/elements while Capitalized are custom components


Rule
-> One root element per component
-> Wrap all in a div or <></>
-> use className -> class keyword is a reserved word

Why Components?
-> Reuseability
    -> Don't repeat yourself
-> Separation of concerns
    -> Don't do too many things in one and the same place (function)


Props(KEY CONCEPT)
-> We can mak our contents reuseable by using the parameters and a concept called props
-> We can pass data to the custom component by adding an attribute
-> We're basically creating our own custom basic HTML element
-> Data should be recieved from outside 
-> Alternative of setting props
-> pass an object to a component
-> Use object destructuring

-> Good practice to keep component small and readable

React(LIFTING STATE UP)
-> We can only communicate from child to parent or parent to child


Derived state concept

Two way binding
-> Whenever you are using a two way binding, you are controlling a component
-> Being controlled by the parent component


Stateless component/ Presentational/ Dumb component
-> More used
-> Doesn't have any internal state, it's just there to output some data.

Understanding keys
-> When rendering a list of data
-> All items are rendered without keys, react reads the item in the array as similar but longer thats why all the item renders

-> Can use jsx expression as a value of a variable

NPM styled components


Props.children to use whats being wrapped shit
-> recieves whats between the component

event prop can be used at any elements
passing function as values to props

onClick, onSelect

react hooks
    -> useState, useEffect, etc.
    -> Only call hooks inside of component functions
    -> Rules of hooks -> call hook function inside of a nested function
    -> Only call hooks on the top level

useState
    -> re-evaluate a component and it's child components when data is changed.

<></> or <Fragment></Fragment> -> Fragments ->

props on a custom component are not automatically used on that component -> has to be sent on the component

forwarding props approach

...name you want to spread to the section you want

pass componenet identifyer as a prop
Working with jsx slots

small caps custom component doesn't work -> use uppercased

When not to lift states

external css are not scoped to the component it's called
    css modules are scoped
    example Header.module.css

    styled components css package


think logically
    initially everything works fine


Portals
    what is a portal
    teleports an html code in a certain part of the html


Component composition -> solution for prop drilling
    Instead of prop drilling -> use a component directly at the parent and give out stuff such as functions, props, etc. instead of sending it to a component and another component

Context API -> another solution for prop drilling
    have all components be wrapped in a content with the data needed
    - context are sometimes stored in a store folder - up to you
    -> can share a function or a value without prop drilling
    another way of accessing or reading a context
        -> useContext is the proper way
        -> any context can also have Consumer instead of Provider
            -> needs a special child or content which could be passed
            -> function is passed as a child

Consuming context -> what happens when context value changes?
    component gets reexecuted when context value changes